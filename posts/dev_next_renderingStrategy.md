---
title: '렌더링 전략 이해'
date: '2026-01-29'
category: 'Dev'
tags: ['Next.js', 'React', 'CSR', 'SSR', 'SSG', 'ISR']
summary: 'CSR과 SSR의 차이점을 중심으로 렌더링 전략 딥다이브'
---

# 렌더링 전략 이해하기

## 브라우저에서 화면이 그려지는 과정

### 렌더링 과정 요약

기본 렌더링 동작은
1. HTML을 받는다
2. CSS를 적용한다
3. JS를 실행한다
4. 그 결과 DOM이 완성된다
5. DOM을 그린다

=>  어디까지 서버가 해주느냐 / 어디부터 브라우저가 하느냐가 렌더링 방식의 차이다.

---

### CSR 

CSR(Client-Side Rendering): <mark>브라우저가 화면 렌더링을 담당</mark>

서버는 다음과 같은 HTML을 제공한다.
```html
<html>
  <body>
    <div id="root"></div>
    <script src="main.js"></script>
  </body>
</html>
```
<mark>화면을 만드는 책임은 HTML이 아닌 JS에 있다.</mark>

여기서 알 수 있는 점은 div태그 하나만 제공해준다는 점은<mark>곧 검색엔진 입장에서 콘텐츠가 없기 때문에 SEO가 구조적으로 불리하다.</mark> 물론 요즘 구글Bot같은 봇이 JS를 실행해주지만 느리고 비용이 매우 크다는 단점이 존재한다.

동작은 다음과 같다
1. HTML 다운로드
2. JS 번들과 CSS파일 다운로드(Long TIME)
3. JS 파싱/실행 (Long TIME)
4. React 실행(DOM준비 과정)
5. React가 API 요청
6. 서버에서 응답
7. React가 DOM 생성
8. 첫 화면 렌더링

5~6번 단계에서도 CSR의 한계는 명확하다.
<1> 문제정의
CSR(Client-Side Rendering) 아키텍처에서는
**데이터가 서버와 브라우저에 동시에 분산**되어 존재하며,
어떤 시점의 어떤 데이터를 기준으로 삼아야 하는지가
구조적으로 명확하게 정의되지 않는다.
=>  **데이터의 최종 책임 위치(authority)가 불분명**해진다.

<2> 구조적 원인
CSR의 기본 데이터흐름은 다음과 같다
```markdown
DB  ←  API Server  ←  Browser (React State / Cache)
```
해당 구조에서 동일 데이터는 동시에 다음 위치에 존재한다.
	1.	DB → 유일한 원본(Source of Truth)이어야 하지만
	2.	API 응답 결과 → 특정 시점의 스냅샷에 불과하며
	3.	브라우저의 상태(state, cache) → UI를 유지하기 위해 장시간 보존된다

=> 즉,** 데이터가 복제된 상태로 여러 계층에 분산**된다.

<3> 구체적 사례로 본 문제 발생 과정
상황
	•	Admin 페이지에서 A 상품의 가격을 10,000원 → 12,000원으로 변경
	•	DB는 즉시 최신 상태(12,000원)를 보유

CSR 환경에서의 사용자 브라우저
	•	이미 이전 시점에 API를 통해 10,000원 데이터를 state로 보유
	•	새로고침이나 명시적인 refetch가 없으면
	•	브라우저는 여전히 10,000원을 “정상 데이터”로 인식

=> 이 시점에서는 **사용자가 보고 있는 데이터가 틀린데이터**인지, **동기화되지 않은게 합법적 상태인지**에 대한 명확한 해답이 없다.

<4> 프론트로의 책임 전가
이러한 불일치 문제를 해결하기 위해 CSR에서는 다음과 같은 전략을 사용한다.
	•	invalidateCache()
	•	refetch()
	•	useEffect 기반 재요청
	•	전역 상태 관리 / 서버 상태 라이브러리

=> 하지만 이는 **데이터 동기화의 책임을 서버가 아닌 프론트엔드가 직접 관리**하게 되어 **브라우저에 의존**하게 되는 문제가 발생한다.

<5> 구조적 한계 평가
그러나 브라우저가 데이터의 최종 권위를 가지기에는 구조적으로 불완전하다.
	•	새로고침 시 상태 소실
	•	여러 탭 간 상태 불일치
	•	네트워크·타이밍 이슈
	•	보안적으로 신뢰 불가

=> <mark>CSR은 데이터의 Authority를 브라우저가 갖지만, 이를 안정적으로 책임질 수 없는 환경 때문에 구조적 불완전성을 내포한다.</mark>

<mark>또한 CSR은 1번과 2번을 제외한 나머지부분을 브라우저가 담당한다 따라서 이에 따라 첫 화면 렌더링이 느리다는 단점이 존재한다.</mark>

#### React 실행파트 딥다이브

<mark>브라우저는 컴포넌트를 함수호출로 해석한다</mark>
```js
<ProductList />
// 위 컴포넌트는 다음과 같다
ProductList(); 
// 해당 함수는 JS객체, 흔히 말하는 Virtual DOM을 반환한다
<ul>
  <li>티셔츠</li>
</ul>
// 위 태그는 다음 아래 JS객체로 반환된다
React.createElement(
  "ul",
  null,
  React.createElement("li", null, "티셔츠")
);
```
<mark>
React가 실행되면 컴포넌트 함수들이 호출되어 JSX가 JS 객체 트리(일반적으로 Virtual DOM이라 부르는 설계도)로 생성된다. react-dom은 이 설계도를 기반으로 실제 DOM을 생성하여 첫 화면을 렌더링한다. 이후 상태나 props 변경으로 새로운 설계도가 생성될 때마다 이전 설계도와 비교(diffing)하여 변경이 필요한 부분만 계산하고, Commit 단계에서 그 차이만 실제 DOM에 반영하여화면이 다시 그려진다.</mark>

구조화 정리
1. Render Phase
  - 컴포넌트 함수 호출
  - 설계도 생성
 - diffing
 - 무엇을 변경할지만 계산

2. Commit Phase
- 계산된 변경사항을 실제 DOM에 반영

결국 종합해보자면 다음과 같이 정리할 수 있다.

CSR은 브라우저가 화면 그리는것을 전부 담당하는 렌더링 전략이다. 다만 이는 다음과 같은 문제를 야기한다.
-  **SEO에 불리**
- **데이터에 대한 책임이 불분명**
- **첫 화면 렌더링이 느림**

이를 해결하기 위해 SSR 개념이 등장했다.

※ <mark>React는 상태변화에 따라 UI를 그리는 라이브러리다. 즉 JS코드일뿐인데 이것을 실행시킬 환경을 브라우저냐 서버냐로 나누는 전략이 곧 CSR과 SSR 방법이다</mark>

## SSR 이해하기

### SSR / SSG / ISR

#### SSR(Server-Side Rendering)

CSR의 단점을 보완하기 위해 SSR이라는 개념이 등장한다.

SSR: <mark>JS 실행을 브라우저가 아닌 서버에서 먼저 하자</mark>

구체적으로는
- **React 실행**
- **데이터 Fetching**
- **DOM 생성**
이 세가지 행위를 서버에서 수행한다.

즉 **완성된 HTML을 브라우저에 전송하는 방식**을 채택한다.

하지만 이러한 복잡한 과정을 서버에서 수행하기 때문에<mark>요청 하나당 처리비용이 높다</mark>. 다시말해 트래픽이 많아지면 **응답시간**과 **CPU 사용** 및 **비용**이 증가한다.

결과적으로 **꼭 최신이어야 하는 페이지** Ex) 로그인, 대시보드 에서만 쓰는게 좋은 전략이다.

이러한 점들로 인해 SSG, ISR 같은 전략이 발생한다.

#### SSG(Static Site Generation)

SSG: <mark>정적 문서를 제공해주는 방식</mark>


목적: 
매번 **새로 만들 필요가 없는 페이지**에 대한 **불필요한 연산**을 줄인다.


동장 방식:
1. 빌드시점에 React 실행
2. HTML 미리 생성
3. 파일로 저장
4. 이후 요청에서는 해당 파일만 전달

장점
- **연산 비용 감소**
- **응답 속도 증가**

사용 예시:
- 회사 소개
- 서비스 설명
- 랜딩 페이지

다만 커머스에서는 데이터 변화가 많기 때문에 SSG만 쓰기 힘들다.

#### ISR(Incremental Static Regneration)

ISR: <mark>SSG처럼 빠르게 주되, 오래된 건 자동으로 새로 만들자</mark>

목적: 
갱신이 필요할 경우 **필요할 때만 연산**하자

동장 방식:
1. 첫 요청 → 기존 HTML 제공
2. 서버 → Stale Time을 확인하고 오래 됐을 경우 Background에서 새 HTML 생성
3. 다음 요청부터 새 HTML 제공

장점:
- **항상 빠르게 페이지 제공**(오래됐다고 HTML을 수정하고 바로 주지 않음)
- **필요할때만 연산** 가능

사용 예시:
- 상품 리스트
- 상품 상세
- 블로그 글

※ <mark>즉 렌더링 전략은 기술적 문제가 아닌 데이터의 시간 민감도 문제이다.</mark>

- 지금 당장 최신이어야 함 → SSR
- 하루에 한 번 바뀌어도 됨 → ISR
- 거의 안 바뀜 → SSG
- 사용자 조작 중심 → CSR






